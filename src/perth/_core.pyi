import enum
from typing import Annotated, TypeAlias, overload
from collections.abc import Sequence
from numpy.typing import NDArray
import numpy

MatrixComplex64: TypeAlias = Annotated[NDArray[numpy.complex64], "[m, n]"]
MatrixComplex128: TypeAlias = Annotated[NDArray[numpy.complex128], "[m, n]"]
VectorFloat64: TypeAlias = Annotated[NDArray[numpy.float64], "[m, 1]"]
VectorInt64: TypeAlias = Annotated[NDArray[numpy.int64], "[m, 1]"]
VectorInt8: TypeAlias = Annotated[NDArray[numpy.int8], "[m, 1]"]

def make_tide_table(
    constituents: Sequence[Constituent] | None = None,
) -> TideTable: ...

class Accelerator:
    def __init__(self, time_tolerance: float, n_constituents: int) -> None: ...
    def clear(self) -> None: ...
    @property
    def values(self) -> list[tuple[Constituent, complex]]: ...
    @property
    def x1(self) -> float: ...
    @property
    def x2(self) -> float: ...
    @property
    def y1(self) -> float: ...
    @property
    def y2(self) -> float: ...

class Axis:
    @overload
    def __init__(
        self, points, epsilon: float = ..., is_periodic: bool = ...
    ) -> None: ...
    @overload
    def __init__(
        self,
        start: float,
        end: float,
        step: float,
        epsilon: float = ...,
        is_periodic: bool = ...,
    ) -> None: ...

class Constituent(enum.Enum):
    ALP2 = ...
    BET1 = ...
    BET2 = ...
    CHI1 = ...
    DEL2 = ...
    EPS2 = ...
    ETA2 = ...
    GAM2 = ...
    I1 = ...
    J1 = ...
    K1 = ...
    K2 = ...
    L2 = ...
    LAM2 = ...
    M1 = ...
    M2 = ...
    M4 = ...
    MF = ...
    MM = ...
    MQ = ...
    MS4 = ...
    MSF = ...
    MSM = ...
    MSQ = ...
    MST = ...
    MT = ...
    MU2 = ...
    N2 = ...
    NODE = ...
    NU2 = ...
    O1 = ...
    OO1 = ...
    P1 = ...
    PHI1 = ...
    PSI1 = ...
    Q1 = ...
    R2 = ...
    RHO1 = ...
    S1 = ...
    S2 = ...
    SA = ...
    SIG1 = ...
    SO1 = ...
    SSA = ...
    STA = ...
    T2 = ...
    TAU1 = ...
    THE1 = ...
    UPS1 = ...
    _2N2 = ...
    _2Q1 = ...

class ConstituentType(enum.Enum):
    LONG_PERIOD = ...
    SHORT_PERIOD = ...

class Inference:
    def __init__(
        self,
        tide_table: TideTable,
        interpolation_type: InterpolationType,
    ) -> None: ...
    def __call__(self, hc: TideTable, lat: float = ...) -> None: ...

class InterpolationType(enum.Enum):
    FOURIER_ADMITTANCE = ...
    LINEAR_ADMITTANCE = ...

class PerthFloat32:
    def __init__(
        self,
        model: TidalModelFloat32,
        group_modulations: bool,
    ) -> None: ...
    def evaluate(
        self,
        lon: VectorFloat64,
        lat: VectorFloat64,
        time: VectorInt64,
        time_tolerance: float = 0.0,
        interpolation_type: InterpolationType | None = None,
        num_threads: int = 0,
    ) -> tuple[VectorFloat64, VectorFloat64, VectorInt8]: ...
    @property
    def tidal_model(self) -> TidalModelFloat32: ...

class PerthFloat64:
    def __init__(
        self,
        model: TidalModelFloat64,
        group_modulations: bool,
    ) -> None: ...
    def evaluate(
        self,
        lon: VectorFloat64,
        lat: VectorFloat64,
        time: VectorInt64,
        time_tolerance: float = 0.0,
        interpolation_type: InterpolationType | None = None,
        num_threads: int = 0,
    ) -> tuple[VectorFloat64, VectorFloat64, VectorInt8]: ...
    @property
    def tidal_model(self) -> TidalModelFloat64: ...

class Quality(enum.Enum):
    EXTRAPOLATED_1 = ...
    EXTRAPOLATED_2 = ...
    EXTRAPOLATED_3 = ...
    INTERPOLATED = ...
    UNDEFINED = ...

class TidalModelFloat32:
    def __init__(
        self, lon: Axis, lat: Axis, row_major: bool = ...
    ) -> None: ...
    def accelerator(self, time_tolerance: float) -> Accelerator: ...
    def add_constituent(
        self,
        constituent: Constituent,
        wave: MatrixComplex64,
    ) -> None: ...
    def empty(self) -> bool: ...
    def identifiers(self) -> list[Constituent]: ...
    def interpolate(
        self, lon: float, lat: float, table: TideTable, acc: Accelerator
    ) -> Quality: ...
    def size(self) -> int: ...

class TidalModelFloat64:
    def __init__(
        self, lon: Axis, lat: Axis, row_major: bool = ...
    ) -> None: ...
    def accelerator(self, time_tolerance: float) -> Accelerator: ...
    def add_constituent(
        self,
        constituent: Constituent,
        wave: MatrixComplex128,
    ) -> None: ...
    def empty(self) -> bool: ...
    def identifiers(self) -> list[Constituent]: ...
    def interpolate(
        self,
        lon: float,
        lat: float,
        table: TideTable,
        acc: Accelerator,
    ) -> Quality: ...
    def size(self) -> int: ...

class TideTable: ...
