import enum
from typing import Annotated, Iterator, TypeAlias, overload
from collections.abc import Sequence
from numpy.typing import NDArray
import numpy

MatrixComplex64: TypeAlias = Annotated[NDArray[numpy.complex64], "[m, n]"]
MatrixComplex128: TypeAlias = Annotated[NDArray[numpy.complex128], "[m, n]"]
VectorFloat64: TypeAlias = Annotated[NDArray[numpy.float64], "[m, 1]"]
VectorInt64: TypeAlias = Annotated[NDArray[numpy.int64], "[m, 1]"]
VectorInt8: TypeAlias = Annotated[NDArray[numpy.int8], "[m, 1]"]
Vector6Int8: TypeAlias = Annotated[NDArray[numpy.int8], "[6, 1]"]
Vector7Int8: TypeAlias = Annotated[NDArray[numpy.int8], "[7, 1]"]

def assemble_constituent_table(
    constituents: Sequence[Constituent] | None = None,
) -> ConstituentTable: ...
def tidal_frequency(doodson_number: Vector6Int8) -> float: ...
def constituent_to_name(
    constituent: Constituent,
) -> str: ...

class Accelerator:
    def __init__(self, time_tolerance: float, n_constituents: int) -> None: ...
    def clear(self) -> None: ...
    @property
    def values(self) -> list[tuple[Constituent, complex]]: ...
    @property
    def x1(self) -> float: ...
    @property
    def x2(self) -> float: ...
    @property
    def y1(self) -> float: ...
    @property
    def y2(self) -> float: ...

class Axis:
    @overload
    def __init__(
        self, points, epsilon: float = ..., is_periodic: bool = ...
    ) -> None: ...
    @overload
    def __init__(
        self,
        start: float,
        end: float,
        step: float,
        epsilon: float = ...,
        is_periodic: bool = ...,
    ) -> None: ...

class Constituent(enum.Enum):
    ALP2 = ...
    BET2 = ...
    BETA1 = ...
    CHI1 = ...
    DEL2 = ...
    EPS2 = ...
    ETA2 = ...
    GAM2 = ...
    J1 = ...
    K1 = ...
    K2 = ...
    L2 = ...
    LAMBDA2 = ...
    M1 = ...
    M13 = ...
    M2 = ...
    M3 = ...
    M4 = ...
    M6 = ...
    M8 = ...
    MF = ...
    MK3 = ...
    MK4 = ...
    MKS2 = ...
    MM = ...
    MN4 = ...
    MO3 = ...
    MQ = ...
    MS4 = ...
    MSF = ...
    MSK6 = ...
    MSM = ...
    MSN2 = ...
    MSN6 = ...
    MSQM = ...
    MST = ...
    MTM = ...
    MU2 = ...
    N2 = ...
    N4 = ...
    NODE = ...
    NU2 = ...
    O1 = ...
    OO1 = ...
    P1 = ...
    PHI1 = ...
    PI1 = ...
    PSI1 = ...
    Q1 = ...
    R2 = ...
    R4 = ...
    RHO1 = ...
    S1 = ...
    S2 = ...
    S4 = ...
    S6 = ...
    SA = ...
    SA1 = ...
    SIGMA1 = ...
    SK4 = ...
    SN4 = ...
    SO1 = ...
    SSA = ...
    STA = ...
    T2 = ...
    TAU1 = ...
    THETA1 = ...
    UPS1 = ...
    _2MK3 = ...
    _2MK6 = ...
    _2MN2 = ...
    _2MN6 = ...
    _2MS2 = ...
    _2MS6 = ...
    _2N2 = ...
    _2Q1 = ...
    _2SM2 = ...
    _2SM6 = ...

class ConstituentTable:
    def __getitem__(self, arg: Constituent) -> TideComponent: ...
    def __iter__(self) -> Iterator[Constituent]: ...
    def __len__(self) -> int: ...

class ConstituentType(enum.Enum):
    LONG_PERIOD = ...
    SHORT_PERIOD = ...

class Inference:
    def __init__(
        self,
        constituent_table: ConstituentTable,
        interpolation_type: InterpolationType,
    ) -> None: ...
    def __call__(
        self, constituent_table: ConstituentTable, lat: float = ...
    ) -> None: ...

class InterpolationType(enum.Enum):
    FOURIER_ADMITTANCE = ...
    LINEAR_ADMITTANCE = ...

class PerthFloat32:
    def __init__(
        self,
        model: TidalModelFloat32,
        group_modulations: bool,
    ) -> None: ...
    def evaluate(
        self,
        lon: VectorFloat64,
        lat: VectorFloat64,
        time: VectorInt64,
        time_tolerance: float = 0.0,
        interpolation_type: InterpolationType | None = None,
        num_threads: int = 0,
    ) -> tuple[VectorFloat64, VectorFloat64, VectorInt8]: ...
    @property
    def tidal_model(self) -> TidalModelFloat32: ...

class PerthFloat64:
    def __init__(
        self,
        model: TidalModelFloat64,
        group_modulations: bool,
    ) -> None: ...
    def evaluate(
        self,
        lon: VectorFloat64,
        lat: VectorFloat64,
        time: VectorInt64,
        time_tolerance: float = 0.0,
        interpolation_type: InterpolationType | None = None,
        num_threads: int = 0,
    ) -> tuple[VectorFloat64, VectorFloat64, VectorInt8]: ...
    @property
    def tidal_model(self) -> TidalModelFloat64: ...

class Quality(enum.Enum):
    EXTRAPOLATED_1 = ...
    EXTRAPOLATED_2 = ...
    EXTRAPOLATED_3 = ...
    INTERPOLATED = ...
    UNDEFINED = ...

def render_constituent_table(
    table: ConstituentTable,
) -> str: ...

class TidalModelFloat32:
    def __init__(
        self, lon: Axis, lat: Axis, row_major: bool = ...
    ) -> None: ...
    def accelerator(self, time_tolerance: float) -> Accelerator: ...
    def add_constituent(
        self,
        constituent: Constituent,
        wave: MatrixComplex64,
    ) -> None: ...
    def empty(self) -> bool: ...
    def identifiers(self) -> list[Constituent]: ...
    def interpolate(
        self,
        lon: float,
        lat: float,
        constituent_table: ConstituentTable,
        acc: Accelerator,
    ) -> Quality: ...
    def size(self) -> int: ...

class TidalModelFloat64:
    def __init__(
        self, lon: Axis, lat: Axis, row_major: bool = ...
    ) -> None: ...
    def accelerator(self, time_tolerance: float) -> Accelerator: ...
    def add_constituent(
        self,
        constituent: Constituent,
        wave: MatrixComplex128,
    ) -> None: ...
    def empty(self) -> bool: ...
    def identifiers(self) -> list[Constituent]: ...
    def interpolate(
        self,
        lon: float,
        lat: float,
        constituent_table: ConstituentTable,
        acc: Accelerator,
    ) -> Quality: ...
    def size(self) -> int: ...

class TideComponent:
    @property
    def doodson_number(self) -> Vector7Int8: ...
    @property
    def is_inferred(self) -> bool: ...
    @property
    def tidal_argument(self) -> float: ...
    @property
    def tide(self): ...
    @property
    def type(self) -> ConstituentType: ...
